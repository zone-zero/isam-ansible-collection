#!/usr/bin/python

__metaclass__ = type
DOCUMENTATION = r'''
---
module: cert_validate
short_description: This module validates a certificate is trusted
description: This module validates a certificate is trusted and optionally validates the DN.
    Note that CRL/OCSP checking is not currently implemented
author: KDM (@zone-zero)
options:
    trusted_roots:
        description: list of PEM-formatted trusted root certificate contents
        type: list
        required: True
    cert:
        description: PEM-formatted certificate to validate.
        type: string
        required: True
    trust_chain:
        description: list of PEM-formatted untrusted intermediate certs
        type: list
        required: False
    cert_dn:
        description: DistinguishedName string. Certificate subject will be compared to this string if present
        type: string
        required: False
'''

EXAMPLES = r'''
# validate cert with intermediate trust chain and confirm cert subject DN matches "CN=somecert,O=someorg"
- name: check certificate is valid
  cert_validate.cert_validate
    trusted_certs: "{{ list_of_pem_encoded_root_certs }}"
    cert: "{{ pem_encoded_cert_to_validate }}"
    trust_chain: "{{ list_of_untrusted_pem_encoded_intermediate_certs }}"
    cert_dn: "CN=somecert,O=someorg"

# validate cert with no trust chain, and no DN matching
  cert_validate.cert_validate
    trusted_certs: "{{ list_of_pem_encoded_root_certs }}"
    cert: "{{ pem_encoded_cert_to_validate }}"


'''



from ansible.module_utils.basic import AnsibleModule
import datetime
from ansible.module_utils.six import string_types
from OpenSSL import crypto
from ldap import dn


#compare dn. return true if matching, false if not.
#check_dn_ldap should be a list of list of tuples in format generated by ldap.dn.str2dn(dn_string)
#check_dn_x509 should be the list of tuples in format generated by Openssl.crypto.X509Name.get_components()
def dn_compare(check_dn_ldap, check_dn_x509):
    dn_is_good = True

    if len(check_dn_ldap) != len(check_dn_x509):
        dn_is_good = False
    else:
        rdn_matches = 0
        for rdn_ldap in check_dn_ldap:
            rdn_ldap_type = rdn_ldap[0][0]
            rdn_ldap_val = rdn_ldap[0][1]
            for rdn_x509 in check_dn_x509:
                rdn_x509_type = rdn_x509[0].decode()
                rdn_x509_val = rdn_x509[1].decode()

                if rdn_ldap_type == rdn_x509_type and rdn_ldap_val == rdn_x509_val:
                    rdn_matches += 1
        
        if rdn_matches != len(check_dn_ldap):
            dn_is_good = False
    
    return dn_is_good


def run_module():
    # define available arguments/parameters a user can pass to the module
    module_args = dict(
        trusted_roots=dict(type='list', required=True),
        cert=dict(type='str', required=True),
        trust_chain=dict(type='list', required=False, default=None),
        cert_dn=dict(type='str', required=False, default=None)
    )

    result = dict(
        changed=False,
        message='',
        failed=False
        
    )

    module = AnsibleModule(
        argument_spec=module_args,
        supports_check_mode=True
    )

    cert = crypto.load_certificate(crypto.FILETYPE_PEM, module.params['cert'])

    #check DN
    if module.params.get('cert_dn'):
        cert_dn =  (dn.str2dn(module.params['cert_dn']))
        if not dn_compare(cert_dn, cert.get_subject().get_components()):
            result["failed"] = True
            result["message"] += "cert DN mismatch!\n"
    
    root_ca_store = crypto.X509Store()

    for root in module.params["trusted_roots"]:
        root_ca_store.add_cert(crypto.load_certificate(crypto.FILETYPE_PEM, root))

    chain = []
    for intermediate in module.params["trust_chain"]:
        chain.append(crypto.load_certificate(crypto.FILETYPE_PEM, intermediate))

    cert_context = crypto.X509StoreContext(root_ca_store, cert, chain)
    try:
        cert_context.verify_certificate()
    except crypto.X509StoreContextError as e:
        result["failed"] = True
        result["message"] = e.args[0][2]

    # in the event of a successful module execution, you will want to
    # simple AnsibleModule.exit_json(), passing the key/value results
    module.exit_json(**result)


def main():
    run_module()

if __name__ == '__main__':
    main()